# Задание

Предлагается написать клиентское и серверное приложение на Java или на Kotlin. Приложение должно использовать только
стандартную библиотеку Java, никакие сторонние фреймворки или библиотеки не должны использоваться. Оба приложения стоит
реализовать в одном java/kt-файле и включать клиент или сервер в зависимости от аргументов командной строки.

## Клиент:

- Работает либо в терминале (bash/cmd.exe), либо в IDE.
- Принимает через аргументы командной строки хост и порт.
- Соединяется с сервером и использует одно TCP-соединение всё время своей работы.
- Ждёт от пользователя ввод числа.
- Отправляет число на сервер.
- Принимает результат с сервера и выводит результат на экран. Результат всегда помещается в одну строку, в конце которой
  есть "\n".
- При вводе пустой строки клиент отсоединяется от сервера и завершает работу.

## Сервер:

- Работает либо в терминале (bash/cmd.exe), либо в IDE.
- Принимает через аргументы командной строки хост и порт для прослушивания.
- Должен уметь работать одновременно с двумя и более клиентами.
- От каждого клиента сервер ждёт число N.
- Сервер подсчитывает N-ое число Фибоначчи и отправляет его клиенту.
- После отправки сервер не разрывает соединение с клиентом, а ждёт от клиента следующее число.

# Решение

Представлено [в файле TCP](src/com/jetbrains/intership/grigorenkopv/TCP.java); код, ответственный за нахождения чисел
Фибоначчи вынесен [в отдельный файл](src/com/jetbrains/intership/grigorenkopv/Fibonacci.java).

Клиент отправляет серверу long N в виде восьми октетов. Такой способ отправки был бы подвержен рассинхронизации,
искажению данных и т.д., но соединение между клиентом и сервером установлено по TCP и в случае какой-либо ошибки сервер
разрывает связь, так что нет риска получить не то, что отправлялось. Дальше сервер находит N-ое число Фибоначи и
отправляет обратно строковое представление его десятичной записи и символ '\n'. Используется кодировка UTF-8 (в данном
случае совпадающая с ASCII благодаря своей обратной совместимости). Решение отправлять сразу строковое представление (а
не само число пооктетно) принято, исходя из того, что в нашей модели, скорее всего, все вычислительно-интенсивные задачи
предпочтительнее выполнять на сервере.

Реализация сервера использует многопоточность и занимается обслуживанием каждого клиента в отдельном потоке. Само же
обслуживание отдельного клиента на дальнейшие потоки не делится, так как предполагается, что пользователь не введёт
следующее N, пока не получит число Фибоначчи в ответ на предыдущее N, а значит и читать ввод одновременно с записью
вывода смысла нет. В параметр backlog серверного сокета установлено значение 50, т.к. это именно то значение, которое
используется по умолчанию Джавой. Оно может быть не самым эффективным, но это уже зависит от конкретного оборудования,
так что подбор оптимального значения этого параметра остаётся "на совести" администратора сервера. Многопоточность
сервера реализована с применением пулла потоков. Количество клиентов, которых сервер может обслуживать одновременно,
равно размеру пулла. Этот параметр здесь задан равным десяти, но опять-таки может быть изменён. 
